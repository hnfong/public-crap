To perform a binary search on a text file directly, we need to efficiently navigate through the file without loading it entirely into memory. This is particularly useful for large files. The goal is to find the byte position of a target string or determine where it should be inserted to maintain order.

Here's a step-by-step approach to achieve this:

1. **Determine File Size**: First, get the total size of the file to know the range for the binary search.

2. **Binary Search Logic**:
   - Use two pointers, `low` and `high`, initialized to 0 and the file size, respectively.
   - Calculate the midpoint `mid` as `(low + high) // 2`.
   - Seek to the `mid` position in the file and read lines from this point to find the start of a complete line.
   - Compare the line with the target string.
   - Adjust `low` and `high` based on the comparison:
     - If the line is less than the target, move `low` to `mid + 1`.
     - If the line is greater than or equal to the target, move `high` to `mid`.

3. **Handling Edge Cases**:
   - Ensure that when seeking to `mid`, you correctly find the start of a line.
   - Handle cases where the file might be empty or the target is not found.

4. **Return the Position**:
   - Once `low` equals `high`, you have found the insertion point or the exact match.

Here's the implementation of the `binary_search_file` function:

```python
def binary_search_file(file_path, target):
    with open(file_path, 'rb') as f:
        # Get the size of the file
        f.seek(0, 2)
        file_size = f.tell()
        
        low, high = 0, file_size
        
        while low < high:
            mid = (low + high) // 2
            f.seek(mid)
            
            # Move to the start of the next line
            if mid > 0:
                f.seek(-1, 1)
                while f.read(1) != b'\n':
                    f.seek(-2, 1)
                    if f.tell() == 0:
                        break
            
            # Read the line from the current position
            line = f.readline()
            if not line:
                high = mid
                continue
            
            # Compare the line with the target
            if line < target:
                low = f.tell()
            else:
                high = f.tell()
        
        # At this point, low == high is the insertion point
        return low

# Example usage:
# Assuming "myfile.txt" contains the example data
# print(binary_search_file("myfile.txt", b"2 by"))  # Should return 17
```

### Explanation:
- **File Seeking**: We use `f.seek(mid)` to jump to the middle of the file. If `mid` is not at the start of a line, we backtrack to find the start of the line.
- **Reading Lines**: `f.readline()` reads the line starting from the current position.
- **Comparison**: We compare the read line with the target using byte comparison.
- **Adjusting Pointers**: Based on the comparison, we adjust `low` and `high` to narrow down the search range.

This approach ensures that we perform the search in O(log(n)) time complexity, where n is the number of bytes in the file, by leveraging the sorted order of lines. [end of text]


