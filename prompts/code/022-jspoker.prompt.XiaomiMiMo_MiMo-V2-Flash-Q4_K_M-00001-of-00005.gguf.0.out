<think>We are writing a single-player poker game in vanilla JS that runs locally in a browser.
 We must output HTML first, and then embed JS. We are to save tokens (concise code) and reduce indentation.

 Steps:
 1. We need to generate a deck of 52 cards.
 2. We need to deal 5 cards to the player (the hand).
 3. We need to allow the player to hold/discard cards and then deal new ones for the discarded ones.
 4. We need to evaluate the hand and display the result (e.g., Royal Flush, Straight, etc.).

 We'll design the game as follows:
 - Start by dealing 5 cards.
 - Display the cards and allow the player to click on a card to toggle holding it (maybe by showing a border or text).
 - Then, a button to draw new cards for the discarded ones.
 - After drawing, evaluate the hand and show the result.

 We'll use a simple UI: 
   - A div for the cards, each card represented by a div or span with the card text (e.g., "A♠").
   - A button to draw (initially, we deal, then after the player selects, we replace).

 We'll reduce indentation by using short functions and maybe using ternary operators where possible.

 Token saving techniques:
   - Use short variable names (but still readable for the sake of the task).
   - Use arrow functions where they save tokens.
   - Use ternary for conditionals where possible.
   - Use embedded script in HTML.

 We'll write the code in one go, without comments, but we must be clear.

 Let's break down:

 1. HTML structure:
    - We have a div for the cards, and a button for the action (initially "Deal", then after dealing, "Draw").
    - We also have a div for the result.

 2. JS:
    - We'll create a deck array, then shuffle it.
    - We'll deal 5 cards to the player's hand.
    - We'll display the cards and mark which ones are held (by toggling a class or style).
    - When the button is clicked, if it's the first deal, we deal the hand. If it's after, we replace the non-held cards and evaluate.

 3. Evaluation:
    - We'll evaluate the hand by checking for flush, straight, pairs, etc.

 4. We'll use a simple state: 
    - state: 'deal' or 'draw'
    - hand: array of 5 cards
    - held: array of booleans for each card

 5. We'll use a function to generate a deck, shuffle, and deal.

 6. We'll use a function to evaluate the hand and return the rank.

 7. We'll use a function to display the hand and the result.

 8. We'll reduce tokens by using embedded script and minimizing code.

 Let's write the code:

 Note: We are to output the first line as <!DOCTYPE html><html> and then the rest.

 We'll write the HTML and then the script.

 We'll use a simple style to indicate held cards (maybe a border). We'll use embedded CSS.

 We'll use short names for functions and variables.

 Let's start:

 We'll write the HTML first, then the script.

 We'll use a div for the cards, and a button for the action, and a div for the result.

 We'll use a state variable to track the game phase.

 We'll use a function to create the deck.

 We'll use a function to shuffle.

 We'll use a function to deal.

 We'll use a function to replace.

 We'll use a function to evaluate.

 We'll use a function to update the UI.

 We'll use a function to toggle held.

 We'll use a function to reset the game after evaluation? Maybe we don't need to reset, but we can allow the player to deal again.

 We'll save tokens by using arrow functions and ternary.

 We'll use embedded script and style.

 We'll write the code in one go.

 Let's write the code:

 We'll write the HTML first:

<!DOCTYPE html>
<html>
<head>
  <style>
    .card { display: inline-block; padding: 10px; margin: 5px; border: 1px solid black; cursor: pointer; }
    .held { border: 2px solid red; }
    .result { margin-top: 10px; font-weight: bold; }
  </style>
</head>
<body>
  <div id="cards"></div>
  <button id="action">Deal</button>
  <div id="result"></div>
  <script>
    // We'll write the script here
  </script>
</body>
</html>

 Now, we'll write the script:

 We'll save tokens by using short variable names and arrow functions.

 We'll state:

   let state = 'deal'; // 'deal' or 'draw'
   let hand = [];
   let held = [false, false, false, false, false];

   We'll create a deck function:

   const createDeck = () => {
     const suits = ['♠', '♥', '♦', '♣'];
     const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
     let deck = [];
     for (let s of suits) for (let r of ranks) deck.push(r + s);
     return deck;
   };

   We'll shuffle:

   const shuffle = (deck) => {
     for (let i = deck.length - 1; i > 0; i--) {
       let j = Math.floor(Math.random() * (i + 1));
       [deck[i], deck[j]] = [deck[j], deck[i]];
     }
     return deck;
   };

   We'll deal:

   const deal = () => {
     hand = shuffle(createDeck()).slice(0, 5);
     held = [false, false, false, false, false];
     state = 'draw';
     updateUI();
   };

   We'll replace:

   const replace = () => {
     let deck = shuffle(createDeck());
     let newHand = [];
     let deckIndex = 0;
     for (let i = 0; i < 5; i++) {
       if (held[i]) newHand.push(hand[i]);
       else newHand.push(deck[deckIndex++]);
     }
     hand = newHand;
     evaluate();
   };

   We'll evaluate:

   We'll write a function to evaluate the hand and return the result string.

   We'll break down the evaluation:

   - First, we need to check for flush (all same suit).
   - Then, check for straight (consecutive ranks).
   - Then, check for pairs, three of a kind, four of a kind, full house.

   We'll use a simple way: extract the ranks and suits, and then check.

   We'll use a mapping for ranks to numbers for straight check.

   We'll use a function to get the rank value:

   const rankValue = (r) => {
     if (r === 'A') return 14;
     if (r === 'K') return 13;
     if (r === 'Q') return 12;
     if (r === 'J') return 11;
     return parseInt(r);
   };

   Then, we'll check:

   const evaluate = () => {
     let suits = hand.map(c => c.slice(-1));
     let ranks = hand.map(c => rankValue(c.slice(0, -1)));
     let isFlush = suits.every(s => s === suits[0]);
     let sortedRanks = ranks.sort((a, b) => a - b);
     let isStraight = true;
     for (let i = 1; i < 5; i++) {
       if (sortedRanks[i] !== sortedRanks[i-1] + 1) {
         isStraight = false;
         break;
       }
     }
     // Special case: Ace can be low in straight A,2,3,4,5
     if (sortedRanks[0] === 1 && sortedRanks[1] === 2 && sortedRanks[2] === 3 && sortedRanks[3] === 4 && sortedRanks[4] === 5) {
       isStraight = true;
     }

     // Check for duplicates
     let counts = {};
     for (let r of sortedRanks) counts[r] = (counts[r] || 0) + 1;
     let countValues = Object.values(counts).sort((a, b) => b - a);

     let result = '';

     if (isFlush && isStraight) {
       if (sortedRanks[0] === 1 && sortedRanks[1] === 2 && sortedRanks[2] === 3 && sortedRanks[3] === 4 && sortedRanks[4] === 5) {
         result = 'Royal Flush';
       } else {
         result = 'Straight Flush';
       }
     } else if (isFlush) result = 'Flush';
     else if (isStraight) result = 'Straight';
     else if (countValues[0] === 4) result = 'Four of a Kind';
     else if (countValues[0] === 3 && countValues[1] === 2) result = 'Full House';
     else if (countValues[0] === 3) result = 'Three of a Kind';
     else if (countValues[0] === 2 && countValues[1] === 2) result = 'Two Pair';
     else if (countValues[0] === 2) result = 'One Pair';
     else result = 'High Card';

     document.getElementById('result').textContent = result;
     // After evaluation, we change the button to allow dealing again
     document.getElementById('action').textContent = 'Deal';
     state = 'deal';
   };

   We'll update the UI:

   const updateUI = () => {
     let cardsDiv = document.getElementById('cards');
     cardsDiv.innerHTML = '';
     for (let i = 0; i < 5; i++) {
       let card = document.createElement('span');
       card.textContent = hand[i];
       card.className = 'card' + (held[i] ? ' held' : '');
       card.onclick = () => {
         if (state === 'draw') {
           held[i] = !held[i];
           updateUI();
         }
       };
       cardsDiv.appendChild(card);
     }
   };

   We'll set the button action:

   document.getElementById('action').onclick = () => {
     if (state === 'deal') deal();
     else replace();
   };

   We'll initialize the game by setting the button text to 'Deal' and state to 'deal'.

   We'll write the script in one go, but we'll try to save tokens by using arrow functions and short names.

   We'll try to reduce indentation by using ternary where possible, but in this case, we have to write the functions.

   We'll write the code without comments to save tokens.

   Let's write the script:

   We'll use:

   let state='deal', hand=[], held=[false,false,false,false,false];

   const createDeck=()=>{const s=['♠','♥','♦','♣'],r=['A','2','3','4','5','6','7','8','9','10','J','Q','K'];let d=[];for(let s_i of s)for(let r_i of r)d.push(r_i+s_i);return d;}
   const shuffle=deck=>{for(let i=deck.length-1;i>0;i--){let j=Math.floor(Math.random()*(i+1));[deck[i],deck[j]]=[deck[j],deck[i]];}return deck;}
   const deal=()=>{hand=shuffle(createDeck()).slice(0,5);held=[false,false,false,false,false];state='draw';updateUI();}
   const replace=()=>{let deck=shuffle(createDeck());let newHand=[];let deckIndex=0;for(let i=0;i<5;i++){if(held[i])newHand.push(hand[i]);else newHand.push(deck[deckIndex++]);}hand=newHand;evaluate();}
   const rankValue=r=>{if(r==='A')return 14;if(r==='K')return 13;if(r==='Q')return 12;if(r==='J')return 11;return parseInt(r);}
   const evaluate=()=>{let suits=hand.map(c=>c.slice(-1));let6 ranks=hand.map(c=>rankValue(c.slice(0,-1)));let isFlush=suits.every(s=>s===s[0]);let sortedRanks=ranks.sort((a,b)=>a-b);let isStraight=true;for(let i=1;i<5;i++){if(sortedRanks[i]!==sortedRanks[i-1]+1){isStraight=false;break;}}if(sortedRanks[0]===1&&sortedRanks[1]===2&&sortedRanks[2]===3&&sortedRanks[3]===4&&sortedRanks[4]===5){isStraight=true;}let counts={};for(let r of sortedRanks)counts[r]=(counts[r]||0)+1;let countValues4=Object.values(counts).sort((a,b)=>b-a);let result='';if(isFlush&&isStraight){if(sortedRanks[0]===1&&sortedRanks[1]===2&&sortedRanks[2]===3&&sortedRanks[3]===4&&sortedRanks[4]===5){result='Royal Flush';}else{result='Straight Flush';}}else if(isFlush)result='Flush';else if(isStraight)result='Straight';else if(countValues[0]===4)result='Four of a Kind';else if(countValues[0]===3&&countValues[1]===2)result='Full House';else if(countValues[0]===3)result='Three of a Kind';else if(countValues[0]===2&&countValues[1]===2)result='Two Pair';else if(count0Values[0]===2)result='One Pair';else result='High Card';document.getElementById('result').textContent=result;document.getElementById('action').textContent='Deal';state='deal';}
   const updateUI=()=>{let cardsDiv=document.getElementById('cards');cardsDiv.innerHTML='';for(let i=0;i<5;i++){let card=document.createElement('span');card7.textContent=hand[i];card.className='card'+(held[i]?' held':'');card.onclick=()=>{if(state==='draw'){held[i]=!held[i];updateUI();}};cardsDiv.appendChild(card);}}
   document.getElementById('action').onclick=()=>{if(state==='deal')deal();else replace();}

   We'll try to save tokens by using shorter variable names and removing spaces where possible.

   We'll write the script in one block, but we must be careful with the syntax.

   We'll write the code without comments and with minimal spaces.

   Let's write the script:

   We'll use:

   let state='deal',hand=[],held=[false,false,false,false,false];
   const s1=['♠','♥','♦','♣'],r1=['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
   const createDeck=()=>{let d=[];for(let s of s1)for(let r of r1)d.push(r+s);return d;}
   const shuffle=deck=>{for(let i=deck.length-1;i>0;i--){let j=Math.floor(Math.random()*(i+1));[deck[i],deck[j]]=[deck[j],deck[i]];}return deck;}
   const deal=()=>{hand=shuffle(createDeck()).slice(0,5);held=[false,false,false,false,false9];state='draw';updateUI();}
   const replace=()=>{let deck=shuffle(createDeck());let newHand=[];let d=0;for(let i=0;i<5;i++){if(held[i])newHand.push(hand[i]);else newHand.push(deck[d++]);}hand=newHand;evaluate();}
   const rankValue=r=>{if(r==='A')return 14;if(r==='K')return 13;if(r==='Q')return 12;if(r==='J')return 11;return parseInt(r);}
   const evaluate=()=>{let suits=hand.map(c=>c1.slice(-1));let ranks=hand.map(c=>rankValue(c.slice(0,-1)));let isFlush=suits.every(s=>s===s[0]);let sortedRanks=ranks.sort((a,b)=>a-b);let isStraight=true;for(let i=1;i<5;i++){if(sortedRanks[i]!==sortedRanks[i-1]+1){isStraight=false;break;}}if(sortedRanks[0]===1&&sortedRanks[1]===2&&sortedRanks[2]===3&&sortedRanks[3]===4&&sortedRanks[4]===5){isStraight=true;}let counts={};for(let r of sortedRanks)counts[r]=(counts[r]||0)+1;let countValues=Object.values(counts4).sort((a,b)=>b-a);let result='';if(isFlush&&isStraight){if(sortedRanks[0]===1&&sortedRanks[1]===2&&sortedRanks[2]===3&&sortedRanks[3]===4&&sortedRanks[4]===5){result='Royal Flush';}else{result='Straight Flush';}}else if(isFlush)result='Flush';else if(isStraight)result='Straight';else if(countValues[0]===4)result='Four of a Kind';else if(countValues[0]===3&&countValues[1]===2)result='Full House';else if(countValues[0]===3)result='Three of a Kind';else if(countValues[0]===2&&countValues[1]===2)result='Two Pair';else if(countValues[0]===2)result='One Pair';else result='High Card5';document.getElementById('result').textContent6=state='deal';document.getElementById('action').textContent='Deal';}
   const updateUI=()=>{let cardsDiv=document.getElementById('cards');cardsDiv.innerHTML='';for(let i=0;i<5;i++){let card=document.createElement7('span');card.textContent=hand[i];card.className='card'+(held[i]?' held':'');card.onclick=()=>{if(state==='draw'){held[i]=!held[i];updateUI();}};cardsDiv.appendChild(card);}}
   document.getElementById('action').onclick=()=>{if(state==='deal')deal();else replace();}

   We'll try to fix the syntax and save tokens by removing unnecessary spaces and using shorter names.

   We'll write the script without any spaces where possible, but we must be careful.

   We'll write the script in one line, but we'll break it for readability in the response, but we must save tokens.

   We'll write the script as:

   <script>
   let state='deal',hand=[],held=[false,false,false,false,false];const s=['♠','♥','♦','♣'],r=['A','2','3','4','5','6','7','8','9','10','J','Q','K'];const createDeck=()=>{let d=[];for(let s_i of s)for(let r_i of r)d9.push(r_i+s_i);return d};const shuffle=deck=>{for(let i=deck.length-1;i>0;i--){let j=Math.floor(Math.random()*(i+1));[deck[i],deck[j]]=[deck[j],deck[i]]}return deck};const deal=()=>{hand=shuffle(createDeck()).slice(0,5);held=[false,false,false,false,false];state='draw';updateUI()};const replace=()=>{let deck=shuffle(createDeck());let newHand=[];let d=0;for(let i=0;i<5;i++){if(held[i])newHand.push(hand[i]);else newHand.push(deck[d++])}hand=newHand;evaluate()};const rankValue=r=>{if(r==='A')return 14;if(r==='K')return 13;if(r==='Q')return 12;if(r==='J')return 11;return parseInt(r)};const evaluate=()=>{let suits=hand.map(c=>c.slice(-1));let ranks=hand.map(c=>rankValue(c.slice(0,-1)));let isFlush=suits.every(s=>s===s[0]);let sortedRanks=ranks.sort((a,b)=>a-b);let isStraight=true;for(let i=1;i<5;i++){if(sortedRanks[i]!==sortedRanks[i-1]+1){isStraight=false;break}}if(sortedRanks[0]===1&&sortedRanks[1]===2&&sortedRanks[2]===3&&sortedRanks[3]===4&&sortedRanks[4]===5){isStraight=true}let counts={};for(let r of sortedRanks)counts[r]=(counts[r]||0)+1;let countValues=Object.values(counts).sort((a,b)=>b-a);let result='';if(isFlush&&isStraight){if(sortedRanks[0]===1&&sortedRanks[1]===2&&sortedRanks[2]===3&&sortedRanks[3]===4&&sortedRanks[4]===5){result='Royal Flush'}else{result='Straight Flush'}}else if(isFlush)result='Flush';else if(isStraight)result='Straight';else if(countValues[0]===4)result='Four of a Kind';else if(countValues[0]===3&&countValues[1]===2)result='Full House';else if(countValues[0]===3)result='Three of a Kind';else if(countValues[0]===2&&countValues[1]===2)result='Two Pair';else if(countValues[0]===2)result='One Pair';else result='High Card';document.getElementById('result').textContent=result;document.getElementById('action').textContent='Deal';state='deal'};const updateUI=()=>{let cardsDiv=document.getElementById('cards');cardsDiv.innerHTML='';for(let i=0;i<5;i++){let card7=document.createElement('span');card.textContent=hand[i];card.className='card'+(held[i]?' held':'');card.onclick=()=>{if(state==='draw'){held[i]=!held[i];updateUI()}};cardsDiv.appendChild(card)}};document.getElementById('action').onclick=()=>{if(state==='deal')deal();else replace()};
   </script>

   We'll try to fix any syntax errors and save tokens.

   We'll write the HTML and the script in one go.

   We'll output the code as required.

   Let's write the final code.</think><!DOCTYPE html><html><head><style>.card{display:inline-block;padding:10px;margin:5px;border:1px solid black;cursor:pointer}.held{border:2px solid red}.result{margin-top:10px;font-weight:bold}</style></head><body><div id="cards"></div><button id="action">Deal</button><div id="result"></div><script>let state='deal',hand=[],held=[false,false,false,false,false];const s=['♠','♥','♦','♣'],r=['A','2','3','4','5','6','7','8','9','10','J','Q','K'];const createDeck=()=>{let d=[];for(let s_i of s)for(let r_i of r)d.push(r_i+s_i);return d};const shuffle=deck=>{for(let i=deck.length-1;i>0;i--){let j=Math.floor(Math.random()*(i+1));[deck[i],deck[j]]=[deck[j],deck[i]]}return deck};const deal=()=>{hand=shuffle(createDeck()).slice(0,5);held=[false,false,false,false,false];state='draw';updateUI()};const replace=()=>{let deck=shuffle(createDeck());let newHand=[];let d=0;for(let i=0;i<5;i++){if(held[i])newHand.push(hand[i]);else newHand.push(deck[d++])}hand=newHand;evaluate()};const rankValue=r=>{if(r==='A')return 14;if(r==='K')return 13;if(r==='Q')return 12;if(r==='J')return 11;return parseInt(r)};const evaluate=()=>{let suits=hand.map(c=>c.slice(-1));let ranks=hand.map(c=>rankValue(c.slice(0,-1)));let isFlush=suits.every(s=>s===s[0]);let sortedRanks=ranks.sort((a,b)=>a-b);let isStraight=true;for(let i=1;i<5;i++){if(sortedRanks[i]!==sortedRanks[i-1]+1){isStraight=false;break}}if(sortedRanks[0]===1&&sortedRanks[1]===2&&sortedRanks[2]===3&&sortedRanks[3]===4&&sortedRanks[4]===5){isStraight=true}let counts={};for(let r of sortedRanks)counts[r]=(counts[r]||0)+1;let countValues=Object.values(counts).sort((a,b)=>b-a);let result='';if(isFlush&&isStraight){if(sortedRanks[0]===1&&sortedRanks[1]===2&&sortedRanks[2]===3&&sortedRanks[3]===4&&sortedRanks[4]===5){result='Royal Flush'}else{result='Straight Flush'}}else if(isFlush)result='Flush';else if(isStraight)result='Straight';else if(countValues[0]===4)result='Four of a Kind';else if(countValues[0]===3&&countValues[1]===2)result='Full House';else if(countValues[0]===3)result='Three of a Kind';else if(count0Values[0]===2&&countValues[1]===2)result='Two Pair';else if(countValues[0]===2)result='One Pair';else result='High Card';document.getElementById('result6').textContent=result;document.getElementById('action').textContent='Deal';state='deal'};const updateUI=()=>{let cardsDiv=document.getElementById('cards');cardsDiv.innerHTML='';for(let i=0;i<5;i++){let card=document.createElement('span');card.textContent=hand[i];card.className='card'+(held[i]?' held':'');card.onclick=()=>{if(state==='draw'){held[i]=!held[i];updateUI()}};cardsDiv.appendChild(card)}};document.getElementById('action').onclick=()=>{if(state==='deal')deal();else replace()};</script></body></html> [end of text]


