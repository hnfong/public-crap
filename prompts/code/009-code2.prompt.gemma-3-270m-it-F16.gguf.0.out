```python
def binary_search_file(file_path, target):
    try:
        with open(file_path, 'rb') as file:
            for byte in file:
                if byte == target:
                    return byte
        return -1  # Target not found
    except FileNotFoundError:
        return -1  # Target not found
```

**Explanation:**

1.  **File Opening:**
    *   The `with open(file_path, 'rb') as file:` statement opens the file in binary read mode (`'rb'`). This is crucial for handling binary files correctly.
    *   The `with` statement ensures that the file is automatically closed even if errors occur.

2.  **Iteration:**
    *   The `for byte in file:` loop iterates through each byte in the file.

3.  **Comparison:**
    *   Inside the loop, `if byte == target:` checks if the current byte is equal to the `target` value.
    *   If the byte is equal, the function immediately returns the corresponding byte position (`byte`).
    *   If the byte is *not* equal, the function returns `-1`.

4.  **Handling `FileNotFoundError`:**
    *   The `try...except` block handles the `FileNotFoundError` exception.  This is a common error that occurs when a file is not found.  The `except FileNotFoundError:` block catches this exception and returns `-1` to indicate that the target was not found.

5.  **Return Value:**
    *   If the loop completes without finding the target, the function returns `-1`.  This indicates that the target was not found in the file.

**Time Complexity:**

*   **O(n)**:  The loop iterates through the file once.
*   **O(1)**:  The function returns the byte position, which is constant.

Therefore, the overall time complexity is O(n), where n is the number of bytes in the file.  This is a very efficient solution for this problem.
 [end of text]


