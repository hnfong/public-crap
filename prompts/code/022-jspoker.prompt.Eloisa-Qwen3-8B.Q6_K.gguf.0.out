<think>
Okay, I need to create a single-player poker game in JavaScript that runs entirely in the browser using vanilla JS. The user wants it concise and with minimal indentation to save tokens. Let me start by outlining the key components.

First, the HTML structure. I'll need a container for the cards, buttons for actions like "Deal" and "Fold", and maybe a display for the player's hand and the dealer's hand. Since it's a browser-only game, I'll use the DOM to render everything.

Next, the JavaScript. I need to handle the game logic: dealing cards, evaluating hands, and determining the winner. Since it's single-player, the player will play against the dealer. I'll need functions to create a deck, shuffle it, deal cards, and evaluate poker hands.

Wait, the user mentioned a standard poker game. I should clarify the rules. Typically, Texas Hold'em is popular, but the user didn't specify. Maybe it's 5-card draw? Let me assume it's 5-card draw for simplicity, as it's straightforward for a single-player game.

In 5-card draw, each player gets 5 cards, and they can replace some with new ones from the deck. The dealer is the computer, so I'll need to simulate the dealer's actions. But the user said "standard poker game," so maybe it's better to go with Texas Hold'em, which is more common. However, Texas Hold'em involves community cards and more complex betting rounds. Since the user wants conciseness, 5-card draw might be better.

Let me go with 5-card draw. The steps would be: deal 5 cards to the player and the dealer, player can discard and draw new cards, then compare hands.

Now, for the code structure. I'll need a deck of cards. Each card can be represented as an object with suit and rank. Then, functions to create the deck, shuffle it, and deal cards.

Evaluating poker hands is crucial. I'll need a function that takes a hand (array of cards) and returns the hand's rank (like straight flush, four of a kind, etc.) and the strength. Then compare the player's hand and the dealer's hand to determine the winner.

But implementing a full poker hand evaluator is complex. Maybe I can use a simplified version or find a way to compare hands without a full evaluator. Alternatively, I can use a lookup table or a ranking system.

Wait, the user wants the code to be concise. So I need to keep the hand evaluation as simple as possible. Maybe I can use a precomputed ranking for each hand, but that might not be feasible. Another approach is to compare the hands by their components, like checking for flushes, straights, etc., but that could be lengthy.

Alternatively, I can use a library, but the user specified vanilla JS and no network requests, so I can't use external libraries. So I have to implement the hand evaluation myself.

Let me think about the hand evaluation. For 5-card draw, the possible hands are: straight flush, four of a kind, full house, flush, straight, three of a kind, two pair, one pair, high card.

I can write a function that checks for each of these conditions in order of their rank. For example, first check if it's a straight flush, then four of a kind, etc.

But writing all that code might take up a lot of tokens. Maybe I can find a way to make it more concise. For example, using helper functions to count occurrences of ranks, check for straights, etc.

Another idea: use a numeric representation for cards. Assign each card a value, like 2-14 for ranks (with 11=Ace, 12=King, etc.), and suits as numbers. Then, sort the cards and check for straights and flushes.

Let me outline the steps for the hand evaluation function:

1. Check if all cards have the same suit (flush).
2. Check if the cards form a straight (consecutive ranks).
3. If both, it's a straight flush.
4. Check for four of a kind: four cards of the same rank.
5. Check for full house: three of one rank and two of another.
6. Check for flush (already checked, but if not straight flush, just flush).
7. Check for straight (already checked, but if not straight flush, just straight).
8. Check for three of a kind.
9. Check for two pair.
10. Check for one pair.
11. Otherwise, high card.

But I need to handle the Ace as both high and low for straights (like A-2-3-4-5). So, I'll need to adjust the straight check for that.

Now, for the game flow:

- Initialize the game: create and shuffle the deck.
- Deal 5 cards to the player and 5 to the dealer.
- Player can choose to discard some cards and draw new ones.
- Dealer then reveals their hand and the winner is determined based on the hand rankings.

But the user didn't specify the betting rounds, so maybe it's a simplified version where the player just tries to make the best hand and then compare with the dealer.

Wait, the user said "standard poker game," so maybe it's better to include a betting round. However, that might complicate things. Let me stick with a simple version where the player can draw new cards to improve their hand, then compare with the dealer's hand.

Now, for the UI: I'll need to display the player's cards, buttons for discarding and drawing, and then a button to reveal the dealer's hand and show the result.

Since the code must be concise, I'll use minimal HTML and inline JavaScript. I'll use divs to represent cards, with background images or text for the card faces. But since the user wants it to run locally, I can't use images, so I'll use text representations like "2♠" etc.

Wait, but the user might not have fonts for suits, so maybe just use text like "2S" for spades. But that's not very visual. Alternatively, I can use Unicode characters for suits: ♠, ♣, ♥, ♦. But that might not display correctly on all systems. However, since it's a browser, it's probably okay.

So, I'll represent each card as a string like "2♠", "Q♥", etc.

Now, putting it all together. Let me start writing the HTML and JavaScript.

First, the HTML structure:

<!DOCTYPE html>
<html>
<head>
    <title>Poker Game</title>
</head>
<body>
    <h1>Poker Game</h1>
    <div id="game">
        <div id="player-hand"></div>
        <button onclick="deal()">Deal</button>
        <button onclick="drawCards()">Draw</button>
        <div id="dealer-hand" style="display:none;"></div>
        <div id="result"></div>
    </div>
    <script>
        // JavaScript code here
    </script>
</body>
</html>

Then, the JavaScript code. I'll need to define the deck, functions to create and shuffle the deck, deal cards, evaluate hands, etc.

Let me start by defining the deck. Each card can be represented as an object with suit and rank, but to save tokens, maybe use a string or a number. Alternatively, use a flat array of strings.

But for evaluation, it's easier to have objects. However, to save tokens, maybe use a numeric code for each card. For example, 0-51 for 52 cards, with 0-12 for clubs, 13-25 for diamonds, etc. But that might complicate the evaluation.

Alternatively, use a string representation and parse it when needed. But that could be inefficient.

Wait, the user wants concise code, so maybe use a flat array of strings for the deck. For example, ["2♠", "3♠", ..., "A♠", "2♣", ...].

Then, when dealing, just push the strings into the player's and dealer's hands.

For evaluation, I'll need to parse the strings to extract rank and suit. But that's manageable.

Let me outline the JavaScript functions:

1. createDeck(): returns an array of 52 card strings.
2. shuffle(deck): shuffles the deck using Fisher-Yates algorithm.
3. deal(): deals 5 cards to player and dealer, updates the UI.
4. drawCards(): allows the player to draw new cards (maybe by replacing selected cards).
5. evaluateHand(hand): returns the hand's rank and strength.
6. compareHands(playerHand, dealerHand): determines the winner.

But for the drawCards function, I need to let the player select which cards to draw. Maybe I can have a button that draws one card at a time, replacing the last discarded card or something. But to keep it simple, maybe the player can click "Draw" to draw a new card, replacing the last card in their hand.

Alternatively, the player can discard any number of cards, and then draw that many. But that might require more UI elements.

Since the user wants conciseness, I'll keep it simple: the player can click "Draw" to draw a new card, replacing the last card in their hand. But that's not very flexible. Maybe the player can click on a card to discard it, and then click "Draw" to draw a new one. But that requires more code.

Alternatively, I can have a "Draw" button that draws a new card and replaces the first card in the hand. But that's arbitrary.

Wait, in 5-card draw, the player can discard any number of cards and draw the same number. So, I need a way for the player to select which cards to discard. But with minimal UI, maybe I can have a button that toggles the discard state for each card, but that would require more code.

To save tokens, maybe I'll implement a simple version where the player can only draw one card at a time, replacing the last card in their hand. That's not ideal, but it's simpler.

So, the flow would be:

- Click "Deal" to start the game.
- Player sees their 5 cards.
- Click "Draw" to draw a new card, replacing the last card in their hand.
- Repeat as needed.
- Click "Draw" again to reveal the dealer's hand and determine the winner.

But the dealer's hand is hidden until the player is done drawing. So, when the player clicks "Draw" again, it reveals the dealer's hand and compares.

Wait, that might not be standard. Usually, the dealer's hand is revealed after the player has finished drawing. So, I'll have a "Done" button instead of "Draw" for the player to indicate they're done, then reveal the dealer's hand.

Let me adjust the UI:

- "Deal" button to start.
- Player's hand displayed.
- "Draw" button to draw a new card (replacing last card).
- "Done" button to finish drawing and reveal dealer's hand.
- Dealer's hand is hidden until "Done" is clicked.
- Result displayed.

But the user might want to draw multiple times. So, the "Draw" button can be clicked multiple times to replace the last card each time.

Now, for the hand evaluation. I need to write a function that takes an array of card strings and returns the hand's rank and strength.

Let me think about how to represent the hand rank. Maybe use a number from 0 to 8, where 8 is straight flush, 7 is four of a kind, etc. Then, for tie-breaking, return an array of values that can be compared lexicographically.

For example:

- Straight flush: highest card in the straight.
- Four of a kind: the rank of the four cards, then the kicker.
- Full house: the rank of the three cards, then the rank of the two cards.
- Flush: the ranks of the cards in descending order.
- Straight: highest card.
- Three of a kind: the rank of the three cards, then the kickers.
- Two pair: the rank of the higher pair, the lower pair, then the kicker.
- One pair: the rank of the pair, then the kickers.
- High card: the ranks in descending order.

So, the evaluateHand function would return an object like { rank: 7, values: [10, 5] } for four of a kind with 10s and a 5 kicker.

Then, compareHands would compare the rank values, and if equal, compare the values arrays.

Now, implementing this in JavaScript. Let's start with the helper functions.

First, createDeck:

function createDeck() {
    const suits = ['♠', '♣', '♥', '♦'];
    const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
    let deck = [];
    for (let suit of suits) {
        for (let rank of ranks) {
            deck.push(rank + suit);
        }
    }
    return deck;
}

Then, shuffle:

function shuffle(deck) {
    for (let i = deck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
    }
    return deck;
}

Deal function:

let playerHand = [];
let dealerHand = [];
let deck = [];

function deal() {
    deck = createDeck();
    shuffle(deck);
    playerHand = deck.splice(0, 5);
    dealerHand = deck.splice(0, 5);
    renderHand('player-hand', playerHand);
    document.getElementById('dealer-hand').style.display = 'none';
    document.getElementById('result').innerText = '';
}

drawCards function:

function drawCards() {
    if (deck.length === 0) return;
    const newCard = deck.pop();
    playerHand[playerHand.length - 1] = newCard;
    renderHand('player-hand', playerHand);
}

renderHand function:

function renderHand(id, hand) {
    const container = document.getElementById(id);
    container.innerHTML = '';
    for (let card of hand) {
        const cardElement = document.createElement('div');
        cardElement.className = 'card';
        cardElement.innerText = card;
        container.appendChild(cardElement);
    }
}

Now, the evaluateHand function. This is the most complex part.

First, parse the cards to extract ranks and suits.

function evaluateHand(hand) {
    // Extract ranks and suits
    const ranks = hand.map(card => card.slice(0, -1));
    const suits = hand.map(card => card.slice(-1));

    // Check for flush
    const isFlush = suits.every(suit => suit === suits[0]);

    // Check for straight
    const rankValues = ranks.map(rank => {
        if (rank === 'J') return 11;
        if (rank === 'Q') return 12;
        if (rank === 'K') return 13;
        if (rank === 'A') return 14;
        return parseInt(rank);
    });

    // Sort the ranks for straight check
    rankValues.sort((a, b) => a - b);

    // Check for Ace-low straight (A-2-3-4-5)
    let isStraight = false;
    if (rankValues[0] === 2 && rankValues[1] === 3 && rankValues[2] === 4 && rankValues[3] === 5 && rankValues[4] === 14) {
        isStraight = true;
        rankValues[4] = 1; // Adjust Ace to 1 for this case
    } else {
        isStraight = rankValues[4] - rankValues[0] === 4;
    }

    // Check for straight flush
    let isStraightFlush = isFlush && isStraight;
    if (isStraightFlush) {
        // Return the highest card in the straight
        return { rank: 8, values: [rankValues[4]] };
    }

    // Check for four of a kind
    const rankCounts = {};
    for (let rank of rankValues) {
        rankCounts[rank] = (rankCounts[rank] || 0) + 1;
    }
    let fourOfAKind = null;
    for (let rank in rankCounts) {
        if (rankCounts[rank] === 4) {
            fourOfAKind = parseInt(rank);
            break;
        }
    }
    if (fourOfAKind !== null) {
        // Find the kicker
        const kicker = rankValues.find(r => r !== fourOfAKind);
        return { rank: 7, values: [fourOfAKind, kicker] };
    }

    // Check for full house
    let threeOfAKind = null;
    let twoOfAKind = null;
    for (let rank in rankCounts) {
        if (rankCounts[rank] === 3) {
            threeOfAKind = parseInt(rank);
        } else if (rankCounts[rank] === 2) {
            twoOfAKind = parseInt(rank);
        }
    }
    if (threeOfAKind !== null && twoOfAKind !== null) {
        return { rank: 6, values: [threeOfAKind, twoOfAKind] };
    }

    // Check for flush
    if (isFlush) {
        // Return the ranks in descending order
        const sortedRanks = [...rankValues].sort((a, b) => b - a);
        return { rank: 5, values: sortedRanks };
    }

    // Check for straight
    if (isStraight) {
        // Return the highest card
        return { rank: 4, values: [rankValues[4]] };
    }

    // Check for three of a kind
    if (threeOfAKind !== null) {
        // Find the kickers
        const kickers = rankValues.filter(r => r !== threeOfAKind);
        kickers.sort((a, b) => b - a);
        return { rank: 3, values: [threeOfAKind, ...kickers] };
    }

    // Check for two pair
    if (twoOfAKind !== null) {
        // Find the other pair and the kicker
        let secondPair = null;
        for (let rank in rankCounts) {
            if (rankCounts[rank] === 2 && parseInt(rank) !== twoOfAKind) {
                secondPair = parseInt(rank);
                break;
            }
        }
        if (secondPair !== null) {
            const kicker = rankValues.find(r => r !== twoOfAKind && r !== secondPair);
            return { rank: 2, values: [Math.max(twoOfAKind, secondPair), Math.min(twoOfAKind, secondPair), kicker] };
        }
    }

    // Check for one pair
    if (twoOfAKind !== null) {
        const kickers = rankValues.filter(r => r !== twoOfAKind);
        kickers.sort((a, b) => b - a);
        return { rank: 1, values: [twoOfAKind, ...kickers] };
    }

    // High card
    const sortedRanks = [...rankValues].sort((a, b) => b - a);
    return { rank: 0, values: sortedRanks };
}

Then, compareHands:

function compareHands(playerHand, dealerHand) {
    const playerEval = evaluateHand(playerHand);
    const dealerEval = evaluateHand(dealerHand);

    if (playerEval.rank > dealerEval.rank) {
        return 'Player wins!';
    } else if (playerEval.rank < dealerEval.rank) {
        return 'Dealer wins!';
    } else {
        // Compare the values arrays
        for (let i = 0; i < playerEval.values.length; i++) {
            if (playerEval.values[i] > dealerEval.values[i]) {
                return 'Player wins!';
            } else if (playerEval.values[i] < dealerEval.values[i]) {
                return 'Dealer wins!';
            }
        }
        return 'It\'s a tie!';
    }
}

Finally, the "Done" button to reveal the dealer's hand and show the result:

function revealDealerHand() {
    document.getElementById('dealer-hand').style.display = 'block';
    renderHand('dealer-hand', dealerHand);
    const result = compareHands(playerHand, dealerHand);
    document.getElementById('result').innerText = result;
}

Now, updating the HTML buttons:

- "Deal" button calls deal().
- "Draw" button calls drawCards().
- "Done" button calls revealDealerHand().

But the user might want to have a single button that toggles between drawing and revealing. However, to keep it simple, I'll have separate buttons.

Putting it all together, the HTML and JavaScript code.

Wait, the user wants the first line to be <!DOCTYPE html><html>, so I'll make sure of that.

Also, the code must be concise, so I'll minimize whitespace and comments.

Let me write the complete code with minimal indentation and comments removed.

Also, I need to make sure that the functions are properly scoped. Since the variables are declared with let, they should be accessible in the global scope.

Now, the final code:

<!DOCTYPE html><html><head><title>Poker Game</title></head><body><h1>Poker Game</h1><div id="game"><div id="player-hand"></div><button onclick="deal()">Deal</button><button onclick="drawCards()">Draw</button><button onclick="revealDealerHand()">Done</button><div id="dealer-hand" style="display:none;"></div><div id="result"></div></div><script>let playerHand=[],dealerHand=[],deck=[];function createDeck(){const suits=['♠','♣','♥','♦'],ranks=['2','3','4','5','6','7','8','9','10','J','Q','K','A'];let deck=[];for(let suit of suits)for(let rank of ranks)deck.push(rank+suit);return deck;}function shuffle(deck){for(let i=deck.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[deck[i],deck[j]]=[deck[j],deck[i]];}}function deal(){deck=createDeck();shuffle(deck);playerHand=deck.splice(0,5);dealerHand=deck.splice(0,5);renderHand('player-hand',playerHand);document.getElementById('dealer-hand').style.display='none';document.getElementById('result').innerText='';}function drawCards(){if(deck.length===0)return;const newCard=deck.pop();playerHand[playerHand.length-1]=newCard;renderHand('player-hand',playerHand);}function renderHand(id,hand){const container=document.getElementById(id);container.innerHTML='';for(let card of hand){const cardElement=document.createElement('div');cardElement.className='card';cardElement.innerText=card;container.appendChild(cardElement);}}function evaluateHand(hand){const ranks=hand.map(card=>card.slice(0,-1));const suits=hand.map(card=>card.slice(-1));const isFlush=suits.every(suit=>suit===suits[0]);const rankValues=ranks.map(rank=>{if(rank==='J')return 11;if(rank==='Q')return 12;if(rank==='K')return 13;if(rank==='A')return 14;return parseInt(rank);});rankValues.sort((a,b)=>a-b);let isStraight=false;if(rankValues[0]===2&&rankValues[1]===3&&rankValues[2]===4&&rankValues[3]===5&&rankValues[4]===14){isStraight=true;rankValues[4]=1}else{isStraight=rankValues[4]-rankValues[0]===4}const isStraightFlush=isFlush&&isStraight;if(isStraightFlush){return{rank:8,values:[rankValues[4]]}}const rankCounts={};for(let rank of rankValues)rankCounts[rank]=(rankCounts[rank]||0)+1;let fourOfAKind=null;for(let rank in rankCounts)if(rankCounts[rank]===4){fourOfAKind=parseInt(rank);break}if(fourOfAKind!==null){const kicker=rankValues.find(r=>r!==fourOfAKind);return{rank:7,values:[fourOfAKind,kicker]}}let threeOfAKind=null;let twoOfAKind=null;for(let rank in rankCounts)if(rankCounts[rank]===3)threeOfAKind=parseInt(rank);else if(rankCounts[rank]===2)twoOfAKind=parseInt(rank);if(threeOfAKind!==null&&twoOfAKind!==null)return{rank:6,values:[threeOfAKind,twoOfAKind]}if(isFlush){const sortedRanks=[...rankValues].sort((a,b)=>b-a);return{rank:5,values:sortedRanks}}if(isStraight)return{rank:4,values:[rankValues[4]]}if(threeOfAKind!==null){const kickers=rankValues.filter(r=>r!==threeOfAKind);kickers.sort((a,b)=>b-a);return{rank:3,values:[threeOfAKind,...kickers]}}if(twoOfAKind!==null){let secondPair=null;for(let rank in rankCounts)if(rankCounts[rank]===2&&parseInt(rank)!==twoOfAKind){secondPair=parseInt(rank);break}if(secondPair!==null){const kicker=rankValues.find(r=>r!==twoOfAKind&&r!==secondPair);return{rank:2,values:[Math.max(twoOfAKind,secondPair),Math.min(twoOfAKind,secondPair),kicker]}}}if(twoOfAKind!==null){const kickers=rankValues.filter(r=>r!==twoOfAKind);kickers.sort((a,b)=>b-a);return{rank:1,values:[twoOfAKind,...kickers]}}const sortedRanks=[...rankValues].sort((a,b)=>b-a);return{rank:0,values:sortedRanks}}function compareHands(playerHand,dealerHand){const playerEval=evaluateHand(playerHand);const dealerEval=evaluateHand(dealerHand);if(playerEval.rank>dealerEval.rank)return'Player wins!';else if(playerEval.rank<dealerEval.rank)return'Dealer wins!';else{for(let i=0;i<playerEval.values.length;i++)if(playerEval.values[i]>dealerEval.values[i])return'Player wins!';else if(playerEval.values[i]<dealerEval.values[i])return'Dealer wins!';return'It\'s a tie!';}}function revealDealerHand(){document.getElementById('dealer-hand').style.display='block';renderHand('dealer-hand',dealerHand);const result=compareHands(playerHand,dealerHand);document.getElementById('result').innerText=result;}</script></body></html>

I think this should work. It's a single-player 5-card draw poker game. The player can deal, draw cards to improve their hand, and then reveal the dealer's hand to see who wins. The hand evaluation is implemented with the helper functions, and the comparison is done based on the hand rankings.

I need to make sure there are no syntax errors. Let me check the code for any missing semicolons or brackets. It looks okay, but I'll double-check the evaluateHand function, especially the Ace-low straight part.

In the straight check, when the ranks are A-2-3-4-5, the code sets rankValues[4] to 1. But in the straight flush check, it uses rankValues[4], which is now 1. That's correct for the straight flush case, but in other cases, like just a straight, the code might not handle it correctly. Wait, no, in the straight check, after adjusting for Ace-low, the code sets isStraight to true and adjusts the rankValues[4] to 1. Then, in the straight flush check, it uses the adjusted value. But in the straight check later, it uses the original rankValues[4], which is 14. Wait, no, the code for straight check is:

if (rankValues[0] === 2 && rankValues[1] === 3 && rankValues[2] === 4 && rankValues[3] === 5 && rankValues[4] === 14) {
    isStraight = true;
    rankValues[4] = 1; // Adjust Ace to 1 for this case
} else {
    isStraight = rankValues[4] - rankValues[0] === 4;
}

So, after this, the rankValues array is modified for the Ace-low straight. Then, in the straight flush check, it uses rankValues[4], which is 1. That's correct because the highest card in the straight is Ace (adjusted to 1), but in the hand evaluation, the values are compared as numbers, so 1 is lower than 2, which is correct for the Ace-low straight.

In the four of a kind and other checks, the rankValues are used as they are. So, for the Ace-low straight, the highest card is 1, which is correct.

I think this should work. The code is concise, uses vanilla JS, and runs entirely in the browser without network requests.
</think>

```html
<!DOCTYPE html><html><head><title>Poker Game</title></head><body><h1>Poker Game</h1><div id="game"><div id="player-hand"></div><button onclick="deal()">Deal</button><button onclick="drawCards()">Draw</button><button onclick="revealDealerHand()">Done</button><div id="dealer-hand" style="display:none;"></div><div id="result"></div></div><script>let playerHand=[],dealerHand=[],deck=[];function createDeck(){const suits=['♠','♣','♥','♦'],ranks=['2','3','4','5','6','7','8','9','10','J','Q','K','A'];let deck=[];for(let suit of suits)for(let rank of ranks)deck.push(rank+suit);return deck;}function shuffle(deck){for(let i=deck.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[deck[i],deck[j]]=[deck[j],deck[i]];}}function deal(){deck=createDeck();shuffle(deck);playerHand=deck.splice(0,5);dealerHand=deck.splice(0,5);renderHand('player-hand',playerHand);document.getElementById('dealer-hand').style.display='none';document.getElementById('result').innerText='';}function drawCards(){if(deck.length===0)return;const newCard=deck.pop();playerHand[playerHand.length-1]=newCard;renderHand('player-hand',playerHand);}function renderHand(id,hand){const container=document.getElementById(id);container.innerHTML='';for(let card of hand){const cardElement=document.createElement('div');cardElement.className='card';cardElement.innerText=card;container.appendChild(cardElement);}}function evaluateHand(hand){const ranks=hand.map(card=>card.slice(0,-1));const suits=hand.map(card=>card.slice(-1));const isFlush=suits.every(suit=>suit===suits[0]);const rankValues=ranks.map(rank=>{if(rank==='J')return 11;if(rank==='Q')return 12;if(rank==='K')return 13;if(rank==='A')return 14;return parseInt(rank);});rankValues.sort((a,b)=>a-b);let isStraight=false;if(rankValues[0]===2&&rankValues[1]===3&&rankValues[2]===4&&rankValues[3]===5&&rankValues[4]===14){isStraight=true;rankValues[4]=1}else{isStraight=rankValues[4]-rankValues[0]===4}const isStraightFlush=isFlush&&isStraight;if(isStraightFlush){return{rank:8,values:[rankValues[4]]}}const rankCounts={};for(let rank of rankValues)rankCounts[rank]=(rankCounts[rank]||0)+1;let fourOfAKind=null;for(let rank in rankCounts)if(rankCounts[rank]===4){fourOfAKind=parseInt(rank);break}if(fourOfAKind!==null){const kicker=rankValues.find(r=>r!==fourOfAKind);return{rank:7,values:[fourOfAKind,kicker]}}let threeOfAKind=null;let twoOfAKind=null;for(let rank in rankCounts)if(rankCounts[rank]===3)threeOfAKind=parseInt(rank);else if(rankCounts[rank]===2)twoOfAKind=parseInt(rank);if(threeOfAKind!==null&&twoOfAKind!==null)return{rank:6,values:[threeOfAKind,twoOfAKind]}if(isFlush){const sortedRanks=[...rankValues].sort((a,b)=>b-a);return{rank:5,values:sortedRanks}}if(isStraight)return{rank:4,values:[rankValues[4]]}if(threeOfAKind!==null){const kickers=rankValues.filter(r=>r!==threeOfAKind);kickers.sort((a,b)=>b-a);return{rank:3,values:[threeOfAKind,...kickers]}}if(twoOfAKind!==null){let secondPair=null;for(let rank in rankCounts)if(rankCounts[rank]===2&&parseInt(rank)!==twoOfAKind){secondPair=parseInt(rank);break}if(secondPair!==null){const kicker=rankValues.find(r=>r!==twoOfAKind&&r!==secondPair);return{rank:2,values:[Math.max(twoOfAKind,secondPair),Math.min(twoOfAKind,secondPair),kicker]}}}if(twoOfAKind!==null){const kickers=rankValues.filter(r=>r!==twoOfAKind);kickers.sort((a,b)=>b-a);return{rank:1,values:[twoOfAKind,...kickers]}}const sortedRanks=[...rankValues].sort((a,b)=>b-a);return{rank:0,values:sortedRanks}}function compareHands(playerHand,dealerHand){const playerEval=evaluateHand(playerHand);const dealerEval=evaluateHand(dealerHand);if(playerEval.rank>dealerEval.rank)return'Player wins!';else if(playerEval.rank<dealerEval.rank)return'Dealer wins!';else{for(let i=0;i<playerEval.values.length;i++)if(playerEval.values[i]>dealerEval.values[i])return'Player wins!';else if(playerEval.values[i]<dealerEval.values[i])return'Dealer wins!';return'It\'s a tie!';}}function revealDealerHand(){document.getElementById('dealer-hand').style.display='block';renderHand('dealer-hand',dealerHand);const result=compareHands(playerHand,dealerHand);document.getElementById('result').innerText=result;}</script></body></html>
``` [end of text]


