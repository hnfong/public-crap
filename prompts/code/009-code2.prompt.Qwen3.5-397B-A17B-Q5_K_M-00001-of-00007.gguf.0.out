To perform a binary search directly on a text file with O(log n) *file operations* (seeks + reads), we treat the file as a sorted array of lines, but we cannot index lines by number without scanning. Instead, we binary-search over **byte offsets** in the file.

Key ideas:

1. The file is sorted lexicographically by line.
2. We can seek to any byte position and read from there.
3. We maintain a search range `[low, high)` over byte offsets.
4. At each step:
   - Pick `mid = (low + high) // 2`.
   - Seek to `mid`, then move forward to the start of the next complete line (because `mid` might be in the middle of a line).
   - Read that line, compare it to `target`.
   - Adjust `low` or `high` accordingly.
5. When the loop ends, `low` will be the byte offset where `target` should be inserted (like `bisect_left`), or the position of the first occurrence if it exists.

To get the “line at or after a given byte offset”, we:
- Seek to `offset`.
- If `offset > 0`, read and discard the partial line up to the next newline (so we start at the beginning of a full line).
- Then read the next line.

Edge cases:
- If we seek past the end of the file, there is no line; treat it as “greater than any line”.
- If the file is empty, return 0.

The comparison must be done on bytes to avoid encoding issues and match the example (`b"2 by"`).

Below is an implementation that:
- Uses only O(log N) seeks/reads (where N is the number of lines).
- Returns the byte offset of the first line `>= target` (insertion point), or the exact position if found.

```python
import os

def binary_search_file(file_path, target: bytes) -> int:
    """
    Perform binary search on a text file whose lines are sorted lexicographically.
    
    Args:
        file_path: Path to the file.
        target: Byte string to search for.
    
    Returns:
        The byte offset (file position) of the first line >= target.
        This matches the behavior of bisect_left:
          - If a line equals target, returns the start byte of that line.
          - Otherwise, returns the byte position where target could be inserted
            while maintaining sorted order.
    """
    file_size = os.path.getsize(file_path)
    if file_size == 0:
        return 0

    low = 0
    high = file_size

    with open(file_path, 'rb') as f:
        while low < high:
            mid = (low + high) // 2

            # Move to the start of the line that contains or follows 'mid'
            f.seek(mid)
            if mid > 0:
                # Discard the rest of the current (partial) line
                f.readline()  # this moves to the beginning of the next line

            line_start = f.tell()
            line = f.readline()

            # If we are at EOF, there is no line here; treat as +infinity
            if not line:
                # No line starting at or after mid => all remaining positions are "greater"
                low = line_start
                continue

            # Remove trailing newline for comparison, but keep in mind that
            # lexicographical order of lines including newline is consistent
            # as long as we treat all lines the same way.
            line_stripped = line.rstrip(b'\n\r')

            if line_stripped < target:
                low = f.tell()  # next search range starts after this line
            else:
                # line_stripped >= target
                high = line_start

    return low
```

### How it works on your example

File content (with byte positions):

```
0: 1 I go to school\n
17: 2 by bus\n
27: foo bar\n
35: hello world\n
47: zoo zoo zoo\n
```

Calling:

```python
pos = binary_search_file("myfile.txt", b"2 by")
```

- The function will eventually land on the line `b"2 by bus"`.
- Since `b"2 by bus".rstrip()` starts with `b"2 by"`, and is `>= b"2 by"`, the search converges to the start of that line.
- It returns `17`, as required.

If the target is not present, e.g. `b"3"`, the function returns the byte offset where a new line `"3..."` should be inserted to keep the file sorted. [end of text]


