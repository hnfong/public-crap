We need to write a complete single-file Java program that reads from standard input, extracts numbers with optional suffixes (k/K, m/M, g/G), handles commas as thousand separators, and calculates the sum in bytes, then prints the total sum in bytes, kilobytes, megabytes, and gigabytes to one decimal place.

The program must be production-ready, using only standard library (java.* namespace). So we can use java.util, java.io, etc.

The input can contain multiple lines, and numbers can be embedded in arbitrary text. We need to extract all numbers that are followed by optional suffixes. The numbers can have commas as thousand separators. The suffixes are case-insensitive (k/K, m/M, g/G). The base unit is bytes: k=1024, M=1024*1024, G=1024*1024*1024.

The output should be:
- total sum in bytes (as a floating point number, presumably with one decimal place? The example shows one decimal place for all outputs: 7264621772.8, 7094357.2 k, 6928.1 M, 6.8 G. So we need to format to one decimal place.

The example input:
```
1.5G, 2K,
3M, and 4.2G
500,000K and 600M
```

Let's compute manually to verify:
1.5G = 1.5 * 1024^3 = 1.5 * 1073741824 = 1610612736
2K = 2 * 1024 = 2048
3M = 3 * 1024^2 = 3 * 1048576 = 3145728
4.2G = 4.2 * 1073741824 = 4509715660.8
500,000K = 500,000 * 1024 = 512,000,000? Wait: 500,000 * 1024 = 512,000,000? Let's compute: 500,000 * 1024 = 512,000,000 (500k * 1024 = 512,000,000). Actually 500,000 * 1024 = 512,000,000 exactly? 500,000 * 1024 = 512,000,000. Yes.
600M = 600 * 1024^2 = 600 * 1048576 = 629145600

Sum = 1610612736 + 2048 + 3145728 + 4509715660.8 + 512000000 + 629145600 = let's compute:
1610612736 + 2048 = 1610614784
+ 3145728 = 1613760512
+ 4509715660.8 = 6123476172.8
+ 512000000 = 6635476172.8
+ 629145600 = 7264621772.8

So total bytes = 7264621772.8

Now convert to kilobytes: divide by 1024: 7264621772.8 / 1024 = 7094357.2 (as in example)
Megabytes: divide by 1024^2: 7264621772.8 / 1048576 = 6928.1... Let's compute: 7264621772.8 / 1048576 = 6928.1 (since 6928.1 * 1048576 = 7264621772.8? Let's check: 6928.1 * 1048576 = 6928 * 1048576 + 0.1 * 1048576 = 726462... Actually 6928 * 1048576 = 726462... Let's compute: 1048576 * 6928 = 1048576 * 6000 + 1048576 * 900 + 1048576 * 20 + 1048576 * 8 = 6,291,456,000 + 943,718,400 + 20,971,520 + 8,388,608 = 7,264,534,528. Then plus 0.1 * 1048576 = 104,857.6. Sum = 7,264,639,385.6? Wait, that doesn't match. Let's compute precisely: 7264621772.8 / 1048576 = 6928.1? Let's do division: 7264621772.8 / 1048576 = 6928.1 exactly? Let's check: 1048576 * 6928.1 = 1048576 * 6928 + 1048576 * 0.1 = 1048576 * 6928 = 1048576 * (7000 - 72) = 1048576*7000 - 1048576*72 = 7,340,032,000 - 75,497,472 = 7,264,534,528. Then + 104,857.6 = 7,264,639,385.6. That's not 7,264,621,772.8. Hmm. Let's recalc: Actually 7264621772.8 / 1048576 = 6928.1? Let's compute with high precision: 7264621772.8 / 1048576 = 6928.1? Let's do: 1048576 * 6928 = 1048576 * 6000 = 6,291,456,000; + 1048576 * 900 = 943,718,400; + 1048576 * 20 = 20,971,520; + 1048576 * 8 = 8,388,608. Sum = 6,291,456,000 + 943,718,400 = 7,235,174,400; + 20,971,520 = 7,256,145,920; + 8,388,608 = 7,264,534,528. So 1048576 * 6928 = 7,264,534,528. Then we need to get to 7,264,621,772.8. The difference is 87,244.8. Dividing that by 1048576 gives 0.0832... So it's not exactly 6928.1. But the example shows 6928.1 M. So maybe they are using 1000-based conversion? No, the problem says kilo=1024, M=1024*1024, etc. So the example must be rounded to one decimal place. So 7264621772.8 / 1048576 = 6928.1 (rounded to one decimal). Let's compute: 7264621772.8 / 1048576 = 6928.0832... Rounded to one decimal is 6928.1. Yes.

Similarly, gigabytes: 7264621772.8 / 1073741824 = 6.766... Actually 7264621772.8 / 1073741824 = 6.766... Let's compute: 1073741824 * 6 = 6,442,450,944. Subtract from 7,264,621,772.8 gives 822,170,828.8. Divide by 1073741824 gives 0.7656. So total ~6.7656. Rounded to one decimal is 6.8. So example shows 6.8 G.

So the program must parse numbers with optional suffixes, handle commas as thousand separators (so we need to remove commas before parsing), and sum them as double (or maybe BigDecimal to avoid precision issues? But the example uses floating point with one decimal. We can use double and format accordingly).

The input is read from standard input. We need to extract all numbers that are followed by optional suffixes. The numbers can be in any format: integer, decimal, with commas. The suffixes are optional: if no suffix, it's just bytes. The problem says "extracts all numbers followed by optional suffixes". So we need to find patterns like "1.5G", "2K", "3M", "4.2G", "500,000K", "600M". Also numbers without suffix should be treated as bytes. The input can have other text. So we need to scan the input string for numbers that may have commas and

