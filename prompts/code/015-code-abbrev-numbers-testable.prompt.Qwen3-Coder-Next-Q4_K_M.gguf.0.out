```python
def abbrev_num(x):
    if x < 0:
        return '-' + abbrev_num(-x)
    
    if x < 1000:
        return str(x)
    
    # Define units in order of magnitude
    units = [
        (1_000_000_000, 'B'),
        (1_000_000, 'M'),
        (1_000, 'K')
    ]
    
    for divisor, suffix in units:
        if x >= divisor:
            # Calculate the value in the unit
            value = x / divisor
            
            # Try different representations to fit in 4 characters
            # First try: one decimal place
            formatted = f"{value:.1f}{suffix}"
            if len(formatted) <= 4:
                return formatted
            
            # Try: no decimal place (integer)
            formatted = f"{round(value)}{suffix}"
            if len(formatted) <= 4:
                return formatted
            
            # Try: two significant digits (e.g., "75K" for 74581)
            # Scale to get two significant digits
            scaled = round(value * 10) / 10  # Round to nearest 0.1
            formatted = f"{scaled}{suffix}"
            if len(formatted) <= 4:
                return formatted
            
            # If still too long, round to integer
            return f"{round(value)}{suffix}"
    
    # For numbers between 1000 and 1000000
    # Try to represent as XXK or XXXK
    if x >= 1000 and x < 1_000_000:
        # Try with K suffix
        value = x / 1000
        
        # Try two-digit integer representation
        formatted = f"{round(value)}K"
        if len(formatted) <= 4:
            return formatted
        
        # Try one decimal place
        formatted = f"{value:.1f}K"
        if len(formatted) <= 4:
            return formatted
        
        # If all else fails, return rounded integer with K
        return f"{round(value)}K"
    
    return str(x)
``` [end of text]


