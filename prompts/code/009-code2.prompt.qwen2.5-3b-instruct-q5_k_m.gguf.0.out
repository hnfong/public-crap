To perform a binary search on a text file directly, we need to simulate the binary search process by reading the file in chunks and comparing the target with the middle element of the current chunk. Here's a Python function that implements this approach:

```python
def binary_search_file(file_path, target):
    def read_chunk(file_path, start, end):
        with open(file_path, 'rb') as file:
            file.seek(start)
            chunk = file.read(end - start)
        return chunk

    def binary_search_in_chunk(chunk, target):
        start, end = 0, len(chunk) - 1
        while start <= end:
            mid = (start + end) // 2
            mid_value = chunk[mid].decode('utf-8')
            if mid_value == target.decode('utf-8'):
                return mid
            elif mid_value < target.decode('utf-8'):
                start = mid + 1
            else:
                end = mid - 1
        return start

    def find_insertion_point(chunk, target):
        start, end = 0, len(chunk) - 1
        while start <= end:
            mid = (start + end) // 2
            mid_value = chunk[mid].decode('utf-8')
            if mid_value == target.decode('utf-8'):
                return mid
            elif mid_value < target.decode('utf-8'):
                start = mid + 1
            else:
                end = mid - 1
        return start

    def binary_search_in_file(file_path, target):
        chunk_size = 1024  # Adjust this size based on your needs
        start = 0
        end = chunk_size
        while start < len(target):
            chunk = read_chunk(file_path, start, end)
            if not chunk:
                break
            position = binary_search_in_chunk(chunk, target)
            if position < len(chunk):
                return position + start
            start = end
            end += chunk_size

        # If the target is not found, find the insertion point
        return find_insertion_point(read_chunk(file_path, start, end), target)

    return binary_search_in_file(file_path, target)

# Example usage
file_path = "myfile.txt"
target = b"2 by"
print(binary_search_file(file_path, target))  # Output should be 17
```

### Explanation:

1. **read_chunk(file_path, start, end)**: This function reads a chunk of the file from the specified `start` to `end` byte positions. It returns the chunk as a byte string.

2. **binary_search_in_chunk(chunk, target)**: This function performs a binary search on the chunk. It returns the position where the target should be inserted to maintain the sorted order.

3. **find_insertion_point(chunk, target)**: This function finds the insertion point for the target in the chunk. It returns the position where the target should be inserted.

4. **binary_search_in_file(file_path, target)**: This function iteratively reads chunks of the file and performs binary search on each chunk. If the target is found, it returns the position. If not, it returns the insertion point.

### Notes:
- The `chunk_size` parameter can be adjusted based on the size of the file and the performance considerations.
- The function assumes that the file is sorted lexicographically and that the target is a byte string.
- The function handles the case where the target is not found by returning the insertion point.

This approach ensures that the function operates in O(log(n)) time complexity, where n is the number of bytes in the file. [end of text]


