<seed:think>
Got it, let's tackle this. The user wants a vanilla JS poker game that runs locally, single-player, concise code, HTML output first line as specified.

First, I need to outline the basic structure: HTML for the UI, JS for game logic. Since it's single-player, probably Texas Hold'em? That's standard. Simplified maybe, but core elements: deck, player hand, community cards, betting (maybe auto-bet for simplicity), deal, flop, turn, river, evaluate hands.

HTML structure: Need sections for player hand, community cards, pot, buttons (Deal, Fold, Check/Call). Keep it simple with divs for cards, text for pot and status.

JS steps: Create a deck. Shuffle it. Deal 2 cards to player. Deal community cards in stages (flop 3, turn 1, river 1). Hand evaluation is crucial—need a function to rank hands (high card, pair, etc.). Since code needs to be concise, the eval function should be simplified but correct.

Conciseness: Reduce indentation. Use arrow functions, ternaries, short variable names. Avoid nested functions where possible. Maybe use arrays for deck, cards represented as objects or strings (e.g., "AH" for Ace of Hearts).

Deck creation: Suits (♠♥♦♣) and ranks (2-A). Combine into all possible cards. Shuffle using Fisher-Yates, but concise version—maybe sort with Math.random().

Dealing: Track the deck index. Deal player hand first (2 cards), then community cards in stages. Buttons to progress: Deal (start game), then maybe a button to reveal next community cards (Flop, Turn, River) or auto-progress.

Hand evaluation: For a given set of 7 cards (2 player + 5 community), determine the best 5-card hand. Simplified ranking: check for pairs, triples, straights, flushes, etc. Assign a rank value (e.g., high card=1, pair=2, ..., royal flush=10) and then kickers.

UI Updates: Function to render cards (display rank/suit, maybe background color). Update pot (start with small blind/big blind, maybe fixed for simplicity). Status messages (e.g., "Deal your hand", "Flop", "Turn", etc.).

Single-player: No opponent AI, so maybe the "game" is just dealing and evaluating the hand. Or simple AI that always calls, but user can fold/check. But to keep it concise, maybe focus on dealing, community cards, and hand evaluation.

Pot: Maybe start with $100, small blind $5, big blind $10. Player starts with $1000 chips. Buttons: Bet, Check, Fold. But for simplicity, maybe auto-bet or just focus on the cards and hand strength.

Wait, user said "standard poker game"—Texas Hold'em is standard. So core elements: player hand, community cards (flop, turn, river), hand ranking.

Let's outline HTML:

- Doctype, html, head with style (for cards, layout).
- Body: Div for pot, div for player hand, div for community cards, div for buttons, div for status.

CSS: Style cards as rectangles with border, display inline-block, margin. Pot and status as text. Buttons styled for clickability.

JS:

- Deck generation: suits = ['♠','♥','♦','♣'], ranks = ['2','3','4','5','6','7','8','9','T','J','Q','K','A']. Deck is suits.flatMap(s => ranks.map(r => ({r,s, v: r<'A'?r:'T'==r?10:'J'==r?11:'Q'==r?12:'K'==r?13:'A'==r?14:0}))). Then shuffle: deck.sort(()=>(Math.random()-0.5)).

- State variables: playerHand = [], community = [], deckIndex = 0, pot = 0, chips = 1000, gameStage = 'pre-flop' (pre-flop, flop, turn, river, showdown).

- Deal function: If pre-flop, deal 2 to player (playerHand = [deck[deckIndex++], deck[deckIndex++]]), then gameStage = 'flop'. Then flop: deal 3 to community (community.push(deck[deckIndex++], deck[deckIndex++], deck[deckIndex++])), gameStage='turn'. Turn: 1 more, then river: 1 more. Then showdown: evaluate hand.

- Render function: Clear player and community divs, render each card (text content: r+s, style based on suit color). Update pot, chips, status.

- Hand evaluation: Function that takes 7 cards, returns best hand rank. Simplified: count ranks, check for flush (all same suit), straight (consecutive ranks), then combinations (4 of a kind, full house, etc.). Assign a score array where first element is hand rank, then kickers.

- Buttons: Deal (start game), Next (progress to flop/turn/river/showdown), Fold (end game, reset).

Now, conciseness: Minimize indentation. Use short variable names. Avoid unnecessary functions. Combine steps where possible.

For example, card rendering: (c) => `<div class="card" style="color:${c.s=='♥'||c.s=='♦'?'red':'black'}">${c.r}${c.s}</div>`.join('') for player and community.

Hand evaluation: Let's make a simple version. For 7 cards, get all combinations of 5, evaluate each, pick the highest rank. But combinations are expensive, but 7C5=21, so manageable.

Alternatively, for simplicity, check for the highest possible hand without checking all combinations (error-prone but concise). Maybe not perfect, but good enough for a demo.

Wait, but to save code, maybe use a simplified ranking. Let's list hand ranks in order:

1. High Card
2. Pair
3. Two Pair
4. Three of a Kind
5. Straight
6. Flush
7. Full House
8. Four of a Kind
9. Straight Flush (Royal is just highest straight flush)

Function to get rank counts: const counts = cards.reduce((a,c) => (a[c.v] = (a[c.v]||0)+1, a), {}); then sort counts by value descending.

Check for flush: cards.every(c => c.s === cards[0].s).

Check for straight: Get unique ranks, sort, check if consecutive. For example, [2,3,4,5,6] or [10,J,Q,K,A] (wrap around A as 1 and 14?).

But handling A as high or low for straight is tricky. For simplicity, maybe only check sequences where the max - min + 1 === 5 and all unique. So A can be 1 or 14, but need to handle low straight (A-2-3-4-5) as well. Maybe duplicate A as 1 in the ranks when checking straight.

This is getting complex, but to keep code concise, maybe skip some edge cases (like royal flush as separate) and just call it straight flush.

Putting it all together:

HTML structure with style inline or in head. JS inside script tag.

State variables: Let's use let for deck, playerHand, community, deckIdx, pot, chips, stage.

Deal function: Depending on stage, deal next cards.

Render function: Update DOM elements with current state.

Hand evaluation function: Returns a string like "Pair of Kings" or the best hand.

Buttons: Add click event listeners to deal, next, fold buttons.

Now, code:

Start with <!DOCTYPE html><html>, then head with style, body with elements, script.

Style: .card { width:50px; height:70px; border:1px solid #333; border-radius:5px; display:inline-block; margin:2px; text-align:center; padding-top:25px; font-size:20px; } .pot, .chips, .status { margin:10px; } button { margin:5px; padding:8px; }

Body: <div class="pot">Pot: $0</div><div class="chips">Chips: $1000</div><div class="status">Click Deal to start</div><div class="player-hand">Your hand:</div><div class="community">Community:</div><button onclick="deal()">Deal</button><button onclick="nextStage()">Next</button><button onclick="fold()">Fold</button>

Script:

Generate deck, shuffle. Then functions deal(), nextStage(), fold(), render(), evaluateHand().

Let's write the script:

let deck, playerHand=[], community=[], deckIdx=0, pot=0, chips=1000, stage='pre-flop';

function initDeck(){deck=[...'♠♥♦♣'].flatMap(s=>[...'23456789TJQKA'].map(r=>({r,s,v:r<'T'?r:'T'==r?10:'J'==r?11:'Q'==r?12:'K'==r?13:'A'==r?14:0})));deck.sort(()=Math.random()-0.5)}

function render(){document.querySelector('.player-hand').innerHTML=playerHand.map(c=>`<div class="card" style="color:${c.s=='♥'||c.s=='♦'?'red':'black'}">${c.r}${c.s}</div>`).join('');document.querySelector('.community').innerHTML=community.map(c=>`<div class="card" style="color:${c.s=='♥'||c.s=='♦'?'red':'black'}">${c.r}${c.s}</div>`).join('');document.querySelector('.pot').textContent=`Pot: $${pot}`;document.querySelector('.chips').textContent=`Chips: $${chips}`;document.querySelector('.status').textContent=stage=='pre-flop'?'Deal your hand':stage=='flop'?'Flop':'turn'?'Turn':'river'?'River':'Showdown: '+evaluateHand()}

function evaluateHand(){let c=[...playerHand,...community],r=c.map(x=>x.v),s=c.map(x=>x.s),v=Array(15).fill(0),f=s.every(x=>x==s[0]),t=[...new Set(r)].sort((a,b)=>a-b),l=t.length,u=t.slice(-5).map((x,i)=>x-t[i]-i),st=u.every(x=>x<1)&&l>=5;v=r.reduce((a,b)=>a[b]++,v);let k=Object.entries(v).sort((a,b)=>b[1]-a[1]||b[0]-a[0]).map(x=>x[0]);return f&&st?'Straight Flush':k[0]==4?'Four of a Kind':k[0]==3&&k[1]==2?'Full House':f?'Flush':st?'Straight':k[0]==3?'Three of a Kind':k[0]==2&&k[1]==2?'Two Pair':k[0]==2?'Pair':'High Card'}

function deal(){initDeck();playerHand=[deck[deckIdx++],deck[deckIdx++]];community=[];deckIdx=2;stage='flop';render()}

function nextStage(){if(stage=='flop')community.push(deck[deckIdx++],deck[deckIdx++],deck[deckIdx++]),stage='turn';else if(stage=='turn')community.push(deck[deckIdx++]),stage='river';else if(stage=='river')stage='showdown';render()}

function fold(){playerHand=[],community=[],deckIdx=0,stage='pre-flop',pot=0;render()}

initDeck();render();

Wait, check for straight: The code above has t as sorted unique ranks, then u is t.slice(-5) mapped to x - t[i] - i. Wait, maybe better to check if the max - min +1 ==5 and all unique. For example, t = [2,3,4,5,6], max=6, min=2, 6-2+1=5, length 5: straight. For low straight (A,2,3,4,5), A is 14, so t would be [2,3,4,5,14], max-min+1=13, which is not 5. So need to handle A as 1 in that case. So maybe create a lowStraight check: if t.includes(2)&&t.includes(3)&&t.includes(4)&&t.includes(5)&&t.includes(14), then straight (A-2-3-4-5). So adjust the straight check:

st = (t.slice(-5).reduce((a,b)=>b-a,0)==4 && l>=5) || (t.includes(2)&&t.includes(3)&&t.includes(4)&&t.includes(5)&&t.includes(14));

That's better. So in evaluateHand(), replace the st line with:

let maxR=t.slice(-1)[0],minR=t[0],st=(maxR-minR===4&&l===5)||(t.includes(2)&&t.includes(3)&&t.includes(4)&&t.includes(5)&&t.includes(14));

Yes, that handles both regular straights and low straights (A-5).

Also, in the v array, initializing with 15 elements (indices 0-14, since ranks go up to 14). Then v[r]++ for each rank r.

The k array is entries of v sorted by count descending, then rank descending. So k[0] is the highest count, etc.

Testing the evaluateHand: For four of a kind, k[0] is 4. Full house: k[0]=3, k[1]=2. etc.

Now, the render function updates the status with the evaluated hand at showdown.

Buttons: Deal resets and deals initial hand. Next progresses through stages. Fold resets.

Pot is hardcoded to 0 for now; maybe add small blind/big blind when dealing. For example, when deal is clicked, pot += 10 (big blind), chips -=10. But user didn't specify betting, but to make it more standard, maybe add that.

Adjust deal function: chips -=10; pot +=10; (big blind). Then status could mention betting, but maybe keep it simple.

Also, in the initial render, status is "Click Deal to start".

Testing code conciseness: Minimized indentation, short variable names, arrow functions avoided (used regular functions for better compatibility, but arrow is okay). Combined some steps.

Possible issues: Card values for 'T' (10) is correct. Suit colors: hearts and diamonds red, others black.

This should work as a basic single-player Texas Hold'em game: deal hand, reveal community cards in stages, evaluate hand at showdown. Runs locally, vanilla JS, HTML output.</seed:think><!DOCTYPE html><html><head><style>.card{width:50px;height:70px;border:1px solid #333;border-radius:5px;display:inline-block;margin:2px;text-align:center;padding-top:25px;font-size:20px;}.pot,.chips,.status{margin:10px;}button{margin:5px;padding:8px;}</style></head><body><div class="pot">Pot: $0</div><div class="chips">Chips: $1000</div><div class="status">Click Deal to start</div><div class="player-hand">Your hand:</div><div class="community">Community:</div><button onclick="deal()">Deal</button><button onclick="nextStage()">Next</button><button onclick="fold()">Fold</button><script>let deck,playerHand=[],community=[],deckIdx=0,pot=0,chips=1000,stage='pre-flop';function initDeck(){deck=[...'♠♥♦♣'].flatMap(s=>[...'23456789TJQKA'].map(r=>({r,s,v:r<'T'?r:'T'==r?10:'J'==r?11:'Q'==r?12:'K'==r?13:'A'==r?14:0})));deck.sort(()=>Math.random()-0.5)}function render(){document.querySelector('.player-hand').innerHTML=playerHand.map(c=>`<div class="card" style="color:${c.s=='♥'||c.s=='♦'?'red':'black'}">${c.r}${c.s}</div>`).join('');document.querySelector('.community').innerHTML=community.map(c=>`<div class="card" style="color:${c.s=='♥'||c.s=='♦'?'red':'black'}">${c.r}${c.s}</div>`).join('');document.querySelector('.pot').textContent=`Pot: $${pot}`;document.querySelector('.chips').textContent=`Chips: $${chips}`;document.querySelector('.status').textContent=stage=='pre-flop'?'Deal your hand':stage=='flop'?'Flop':stage=='turn'?'Turn':stage=='river'?'River':'Showdown: '+evaluateHand()}function evaluateHand(){let c=[...playerHand,...community],r=c.map(x=>x.v),s=c.map(x=>x.s),v=Array(15).fill(0),f=s.every(x=>x==s[0]),t=[...new Set(r)].sort((a,b)=>a-b),l=t.length,maxR=t.slice(-1)[0],minR=t[0],st=(maxR-minR===4&&l===5)||(t.includes(2)&&t.includes(3)&&t.includes(4)&&t.includes(5)&&t.includes(14));v=r.reduce((a,b)=>a[b]++,v);let k=Object.entries(v).sort((a,b)=>b[1]-a[1]||b[0]-a[0]).map(x=>x[0]);return f&&st?'Straight Flush':k[0]==4?'Four of a Kind':k[0]==3&&k[1]==2?'Full House':f?'Flush':st?'Straight':k[0]==3?'Three of a Kind':k[0]==2&&k[1]==2?'Two Pair':k[0]==2?'Pair':'High Card'}function deal(){initDeck();playerHand=[deck[deckIdx++],deck[deckIdx++]];community=[];deckIdx=2;stage='flop';chips-=10;pot+=10;render()}function nextStage(){if(stage=='flop')community.push(deck[deckIdx++],deck[deckIdx++],deck[deckIdx++]),stage='turn';else if(stage=='turn')community.push(deck[deckIdx++]),stage='river';else if(stage=='river')stage='showdown';render()}function fold(){playerHand=[],community=[],deckIdx=0,stage='pre-flop',pot=0;render()}initDeck();render();</script></body></html> [end of text]


