def abbrev_num(x: int) -> str:
    if x == 0:
        return "0"
    exp = 0
    n = x
    while n >= 1000:
        n //= 1000
        exp += 1
    # Now n is the value in the correct magnitude, exp is the power (K=3, M=6, etc)
    if exp == 0:
        return f"{x}"
    factor = 10 ** (3 - exp) if exp in (3, 6) else 10 ** (6 - exp) if exp in (6,) else 1
    val = n * factor
    # Decide the unit
    units = ['','K','M','B','T','L','L']
    unit_idx = exp // 3 if exp % 3 == 0 else (exp + 3) // 3 - 1
    unit = units[unit_idx] if unit_idx < len(units) else ''
    # Round val to 2 significant digits
    s = f"{val:.2g}"
    # Remove trailing .0 if it's an integer
    if '.' in s and s[-1] == '0' and len(s.split('.')[1]) == 1:
        s = s.rstrip('0').rstrip('.')
    # Truncate to 2-3 digits if needed to keep <=4 chars including unit
    max_len = 4 - len(unit)
    if max_len > 0:
        num_part = s[:max_len]
        if len(num_part) == 0:
            num_part = '1'
        if len(num_part) > 2:
            num_part = num_part[:2]
        # If we need a decimal, keep one digit after
        if '.' in num_part:
            num_part = num_part[:2] + '.' + num_part[2:3] if len(num_part) > 2 else num_part + '.'
        else:
            num_part += '0' * (max_len - len(num_part))
        if len(num_part) > 2:
            num_part = num_part[:2]
        if unit:
            return f"{num_part}{unit}"
        else:
            return num_part[:max_len]
    else:
        # Can fit the whole number
        if len(s) > 2:
            return f"{s[0]}{s[1]:<1}{unit}"
        else:
            return s + unit if unit else s [end of text]


