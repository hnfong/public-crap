To perform a binary search on a text file directly, we need to consider the file as a sequence of lines and perform the search based on the lexicographical order of these lines. The challenge here is that we cannot load the entire file into memory, so we need to read only the necessary parts of the file to perform the search efficiently.

Here's a step-by-step approach to achieve this:

1. **Determine the File Size**: First, we need to know the total size of the file in bytes.
2. **Binary Search Logic**: Use binary search to find the target line. This involves:
   - Calculating the middle position in the file.
   - Reading the line at the middle position.
   - Comparing the target with the middle line.
   - Adjusting the search range based on the comparison.
3. **Reading Lines Efficiently**: To read a line at a specific position, we need to:
   - Seek to the middle position.
   - Read until the end of the line to get the full line content.
   - Handle edge cases where the middle position might be in the middle of a line.

Here's the implementation of the `binary_search_file` function:

```python
def binary_search_file(file_path, target):
    def read_line_at_position(file, position):
        file.seek(position)
        # Read until the end of the line
        line = file.readline()
        return line

    def find_line_start(file, position):
        # Move backwards to find the start of the line
        if position == 0:
            return 0
        file.seek(position)
        while position > 0 and file.read(1) != b'\n':
            position -= 1
            file.seek(position)
        if position > 0:
            position += 1  # Move past the newline character
        return position

    with open(file_path, 'rb') as file:
        file_size = file.seek(0, 2)
        low, high = 0, file_size

        while low < high:
            mid = (low + high) // 2
            mid_start = find_line_start(file, mid)
            line = read_line_at_position(file, mid_start)

            if line == target:
                return mid_start
            elif line < target:
                low = mid_start + len(line)
            else:
                high = mid_start

        # If the target is not found, return the insertion point
        return low

# Example usage:
# print(binary_search_file("myfile.txt", b"2 by"))
```

### Explanation:
1. **`read_line_at_position`**: This function reads a line starting from a given position.
2. **`find_line_start`**: This function finds the start of the line by moving backwards from a given position until it finds a newline character.
3. **Binary Search Loop**: The main loop performs the binary search:
   - Calculate the middle position.
   - Find the start of the line at the middle position.
   - Read the line at the start position.
   - Compare the target with the read line.
   - Adjust the search range based on the comparison.
4. **Return the Insertion Point**: If the target is not found, the loop exits and returns the position where the target should be inserted to maintain the sorted order.

This approach ensures that we perform the binary search in O(log(n)) operations, where n is the number of lines in the file. [end of text]


