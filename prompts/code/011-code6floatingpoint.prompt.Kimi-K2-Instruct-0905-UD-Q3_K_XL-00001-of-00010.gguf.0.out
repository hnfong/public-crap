IEEE-754 double-precision (Python’s float) is assumed throughout.

Q1.  
The loop  
```
x = 0.0
while x < math.inf:
    x += 1.0
```
adds 1.0 to x each iteration.  
Once x reaches 2^53 (≈ 9 × 10^15) the spacing between successive representable numbers becomes 2.0, so  
`x + 1.0` rounds back to `x`.  
From that point on `x` stops growing and the condition `x < math.inf` is always true.  
Hence the loop never terminates and the program runs forever; **no value is ever printed**.

Q2.  
```
x = 1.0
while x < math.inf:
    x = x * 1.001
```
Each iteration multiplies x by 1.001.  
The value grows without bound; after a few thousand iterations it overflows to `+inf`.  
The next test `inf < math.inf` is false, so the loop stops and the subsequent  
```
print(x)
```
prints  
```
inf
```
This is different from Q1, which never prints anything.

Q3.  
```
x = 0.0
inc = float(input("Enter a number"))
while x < math.inf:
    x += inc
print("Done")
```
“Done” is printed exactly when the addition `x += inc` produces `+inf`.  
That happens for any positive inc that is large enough to overflow when added to the largest finite double.  
Two concrete examples:

- inc = 1e308  
- inc = 1e400  (parsed as `inf` by float(), so the very first addition turns x into `inf`)

Any strictly positive inc will eventually overflow, so there are infinitely many such inputs; zero or negative inc would make the loop run forever. [end of text]


