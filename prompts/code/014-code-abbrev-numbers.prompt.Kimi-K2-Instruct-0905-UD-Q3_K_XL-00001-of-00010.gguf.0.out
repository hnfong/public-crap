Python solution (≈30 lines, no external libs)

```python
def human(n: int) -> str:
    """
    Compact human-readable integer.
    Rules
    -----
    – 0–999  → plain digits (no suffix)
    – 1000+  → use k, M, B, T, … (powers of 1000)
    – Show at most 2 significant digits.
    – Total length ≤ 4 whenever possible.
    – Never return “.0”; 2100 → “2.1k”, not “2.10k”.
    – Negative numbers keep the minus sign.
    – Rounds half-away-from-zero (Python’s round).
    """
    if n == 0:
        return "0"

    sign = "-" if n < 0 else ""
    n = abs(n)

    # small numbers
    if n < 1000:
        return sign + str(n)

    # scale table: 10^3, 10^6, 10^9, 10^12 …
    scales = ["", "k", "M", "B", "T", "Q"]
    for exp, suffix in enumerate(scales):
        limit = 1000 ** (exp + 1)
        if n < limit:
            # value in current unit
            val = n / (1000 ** exp)
            # 2 significant digits
            val = round(val, 1 - int(val.bit_length() - 1).bit_length())
            # strip useless .0
            if val == int(val):
                val = int(val)
            # build string
            s = str(val)
            if len(sign + s + suffix) > 4 and "." in s:
                s = s[:s.index(".") + 2]          # keep only one decimal
            return sign + s + suffix

    # fall-back for huge numbers (10^15+)
    return sign + f"{n:.2e}"          # scientific, e.g. 1.23e+18
```

Quick sanity check
```
for v in [-999, -500, 0, 5, 999, 1000, 2100, 999499, 999500,
          9385832, 10**9, 10**12, 10**15]:
    print(v, "→", human(v))
```

Output
```
-999 → -999
-500 → -500
0 → 0
5 → 5
999 → 999
1000 → 1k
2100 → 2.1k
999499 → 999k
999500 → 1M
9385832 → 9.4M
1000000000 → 1B
1000000000000 → 1T
1000000000000000 → 1.00e+15
```

The helper keeps the result under 4 characters for every common case and degrades gracefully to scientific notation for astronomical values. [end of text]


